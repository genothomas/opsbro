#!/usr/bin/env python

# Copyright (C) 2014:
#    Gabes Jean, naparuba@gmail.com


import optparse
import sys
import os
import json
import imp
import signal
import traceback

sys.path.append('.')

from opsbro.log import cprint, logger, is_tty
from opsbro import cli as cli_mod
from opsbro.configurationmanager import configmgr
from opsbro.collectormanager import collectormgr
from opsbro.modulemanager import modulemanager
from opsbro.packer import packer
from opsbro.info import VERSION, BANNER, TXT_BANNER
from opsbro.misc.bro_quotes import get_quote
from opsbro.defaultpaths import DEFAULT_LOG_DIR, DEFAULT_CFG_FILE, DEFAULT_CFG_DIR, DEFAULT_DATA_DIR

logger.setLevel('WARNING')

CLI = None


# Handle some signals
def sig_handler(signalnum, handle):
    """ Handle some signals """
    sys.exit(0)


signal.signal(signal.SIGTERM, sig_handler)
signal.signal(signal.SIGINT, sig_handler)

CONFIG = {}


class Dummy():
    def __init__(self):
        pass


class CLIEntry(object):
    def __init__(self, f, args, description):
        self.f = f
        self.args = args
        self.description = description


# Commander is the main class for managing the CLI session and behavior
class CLICommander(object):
    def __init__(self, config, opts):
        self.keywords = {}
        
        self.config = config
        
        log_dir = config.get('log', DEFAULT_LOG_DIR)  # '/var/lib/opsbro'
        log_level = config.get('log_level', 'INFO')
        # early set the logger part
        logger.load(log_dir, '(cli)')
        logger.setLevel(log_level)
        
        cfg_dir = DEFAULT_CFG_DIR
        if not os.path.exists(cfg_dir):
            logger.error('Configuration directory [%s] is missing' % cfg_dir)
            sys.exit(2)
        
        # We need the main cfg_directory
        configmgr.load_cfg_dir(cfg_dir, load_focus='agent')
        
        data_dir = os.path.abspath(os.path.join(DEFAULT_DATA_DIR))  # '/var/lib/opsbro/'
        
        # We can start with a void data dir
        if not os.path.exists(data_dir):
            os.mkdir(data_dir)
        
        # Then we will need to look at other directories, list from
        # * global-configration = common to all nodes
        # * zone-configuration = common to zone nodes
        # * local-configuration = on this specific node
        global_configuration = os.path.join(data_dir, 'global-configuration')
        zone_configuration = os.path.join(data_dir, 'zone-configuration')
        local_configuration = os.path.join(data_dir, 'local-configuration')
        
        # Ask the packer to load pack descriptions so it will be able to
        # give us which pack directories must be read (with good order)
        packer.load_pack_descriptions(global_configuration, 'global')
        packer.load_pack_descriptions(zone_configuration, 'zone')
        packer.load_pack_descriptions(local_configuration, 'local')
        
        # Now that packs are load and clean, we can load collector code from it
        configmgr.load_collectors_from_packs()
        
        # Now that packs are load and clean, we can load modules code from it
        configmgr.load_modules_from_packs()
        
        # We load configuration from packs, but only the one we are sure we must load
        configmgr.load_configuration_from_packs()
        
        # We can now give configuration to the collectors
        collectormgr.get_parameters_from_packs()
        
        # We can now give configuration to the modules
        modulemanager.get_parameters_from_packs()
        
        # We will now try to load the keywords from the modules
        self.load_cli_mods(opts)
    
    
    # We should look on the sys.argv if we find a valid keywords to
    # call in one loop or not.
    def hack_sys_argv(self):
        command_values = []  # Know which function to CALL
        internal_values = []  # with which parameters
        
        founded = False
        ptr = self.keywords
        
        for arg in sys.argv[1:]:  # don't care about the program name
            # Maybe it's a global one
            if not founded and arg in self.keywords['global']:
                founded = True
                command_values.insert(0, 'global')
            if not founded and arg in ptr:
                founded = True
            # Did we found it?
            if founded:
                command_values.append(arg)
            else:  # ok still not, it's for the opsbro command so
                internal_values.append(arg)
        
        logger.debug('Internal args %s' % internal_values)
        logger.debug('Command values %s' % command_values)
        
        # Ok, really hack sys.argv to catch PURE cli argument (like -D or -h)
        sys.argv = internal_values
        return command_values
    
    
    # For some keywords, find (and create if need) the keywords entry in the keywords tree
    def insert_keywords_entry(self, keywords, e):
        # Simulate 'global' entry before top level entries
        if len(keywords) == 1:
            keywords = ['global', keywords[0]]
        ptr = self.keywords
        for keyword in keywords[:-1]:
            if keyword not in ptr:
                ptr[keyword] = {}
            ptr = ptr[keyword]
        entry_last_key = keywords[-1]
        ptr[entry_last_key] = e
    
    
    def create_cli_entry(self, f, raw_entry):
        m_keywords = raw_entry.get('keywords', [])
        args = raw_entry.get('args', [])
        description = raw_entry.get('description', '')
        e = CLIEntry(f, args, description)
        # Finally save it
        self.insert_keywords_entry(m_keywords, e)
    
    
    def get_cli_entry_from_args(self, command_args):
        logger.debug("ARGS: %s" % command_args)
        if len(command_args) == 1:
            command_args = ['global', command_args[0]]
        
        ptr = self.keywords
        for arg in command_args:
            if arg not in ptr:
                logger.error('UNKNOWN command argument %s' % arg)
                return None
            ptr = ptr[arg]
            # Reached a leaf
            if isinstance(ptr, CLIEntry):
                return ptr
        return ptr
    
    
    def load_cli_mods(self, opts):
        # Main list of keywords for the first parameter
        self.keywords.clear()
        
        # CLI are load from the packs
        cli_mods_dirs = []
        pack_directories = packer.give_pack_directories_to_load()
        
        for (pname, level, dir) in pack_directories:
            cli_directory = os.path.join(dir, 'cli')
            if os.path.exists(cli_directory):
                cli_mods_dirs.append(cli_directory)
        
        logger.debug("Loading the cli directories %s" % cli_mods_dirs)
        
        # Link the CONFIG objet into the common
        # cli mod
        cli_mod.CONFIG = self.config
        
        for d in cli_mods_dirs:
            f = os.path.join(d, 'cli.py')
            if os.path.exists(f):
                dname = os.path.split(d)[1]
                # Let's load it, but first att it to sys.path
                sys.path.insert(0, d)
                # Load this PATH/cli.py file
                m = imp.load_source(dname, f)
                # Unset this sys.path hook, we do not need anymore
                sys.path = sys.path[1:]
                
                exports = getattr(m, 'exports', {})
                for (f, raw_entry) in exports.iteritems():
                    self.create_cli_entry(f, raw_entry)
        
        logger.debug('We load the keywords %s' % self.keywords)
    
    
    # We need to have the command arguments clean from the keywords, so we only have the argument of the function()
    # that will be called
    def clean_command_args(self, command_args):
        ptr = self.keywords
        idx = 0
        for arg in command_args:
            if arg not in ptr:
                return command_args[idx:]
            ptr = ptr[arg]
            idx += 1
            if isinstance(ptr, CLIEntry):
                return command_args[idx:]
        return []
    
    
    # Execute a function based on the command line
    def one_loop(self, command_args):
        logger.debug("ARGS: %s" % command_args)
        
        entry = self.get_cli_entry_from_args(command_args)
        if entry is None:
            self.print_list(command_args[0])
            return
        
        command_args = self.clean_command_args(command_args)
        
        # Now prepare a new parser, for the command call this time
        command_parser = optparse.OptionParser('', version="%prog " + VERSION)
        command_parser.prog = ''
        
        for a in entry.args:
            n = a.get('name', None)
            if n is None:
                continue
            default = a.get('default', Dummy())
            description = a.get('description', '')
            _type = a.get('type', 'standard')
            if n.startswith('-'):
                # Get a clean version of the parameter, without - or --
                dest = n[1:]
                if dest.startswith('-'):
                    dest = dest[1:]
                # And if the parameter is like download-only, map it to
                # download_only
                dest = dest.replace('-', '_')
                # add_option parameters, common ones
                d = {'dest': dest, 'help': (description)}
                # If bool setup it
                if _type == 'bool':
                    d['action'] = 'store_true'
                # and if we got a real default, use it
                if not isinstance(default, Dummy):
                    d['default'] = default
                command_parser.add_option(n, **d)
        
        cmd_opts, cmd_args = command_parser.parse_args(command_args)
        f = entry.f
        logger.debug("CALLING " + str(f) + " WITH " + str(cmd_args) + " and " + str(cmd_opts))
        try:
            f(*cmd_args, **cmd_opts.__dict__)
        except TypeError, exp:
            logger.error('Bad call: missing or too much arguments: %s' % exp)
            sys.exit(2)
        except Exception, exp:
            logger.error('The call did fail: %s' % (str(traceback.print_exc())))
    
    
    def print_completion(self, args):
        to_analayses = []
        for (k, d) in self.keywords.iteritems():
            if k != 'global':
                to_analayses.append([k])
                for sub_k in d.keys():
                    to_analayses.append([k, sub_k])
            else:
                for sub_k in d.keys():
                    to_analayses.append([sub_k])
        
        for to_analyse in to_analayses:
            # if we are too far in the command, cannot be this one
            if len(args) > len(to_analyse):
                # print "SKIP impossible match", to_analyse
                continue
        
        res = []
        # so args <= to_analyse
        # Special case: no args, give only first level items
        if len(args) == 0:
            for to_analyse in to_analayses:
                if len(to_analyse) == 1:
                    res.append(to_analyse[0])
        elif len(args) == 1:
            arg = args[0]
            # Maybe it's a keyword, if so automatically give sub commands
            if arg in self.keywords:
                d = self.keywords[arg]
                res = d.keys()
            elif arg in self.keywords['global']:  # maybe in global directly
                res = self.keywords['global'].keys()
            else:  # ok not directly a keyword, try to match
                for k in self.keywords.keys():
                    if k.startswith(arg):
                        res.append(k)
                # Also look at global entries
                for k in self.keywords['global'].keys():
                    if k.startswith(arg):
                        res.append(k)
        else:  # ok we will have to match/filter something
            # Maybe we have a perfect entry, if so return nothing because we already found the entry
            perfect_match = False
            for to_analyse in to_analayses:
                if to_analyse == args:
                    # print "PERFECT FIT", to_analyse
                    perfect_match = True
            # Ok try to guess so
            if not perfect_match:
                last_partial = args[-1]
                full_match = args[:-1]
                for to_analyse in to_analayses:
                    propose_last_partial = to_analyse[-1]
                    propose_full_match = to_analyse[:-1]
                    if propose_full_match != full_match:  # This propose entry is not matching full match
                        continue
                    if propose_last_partial.startswith(last_partial):  # valid entry found
                        res.append(propose_last_partial)
        
        print ' '.join(res)
        return
    
    
    def __print_sub_level_tree(self, ptr, prefix):
        cmds = ptr.keys()
        cmds.sort()
        for k in cmds:
            entry = ptr[k]
            # Tree not finish? go for it
            if isinstance(entry, dict):
                self.__print_sub_level_tree(entry, '%s %s' % (prefix, k))
                continue
            s = k.ljust(25)
            if prefix:
                s = '%s %s' % (prefix, k)
                s = s.ljust(25)
            cprint('\t%s ' % s, 'green', end='')
            cprint(': %s' % entry.description)
    
    
    def print_list(self, keyword=''):
        print "Available commands:"
        sub_cmds = self.keywords.keys()
        sub_cmds.remove('global')
        sub_cmds.sort()
        sub_cmds.insert(0, 'global')
        
        for cmd in sub_cmds:
            # If we did filter a specific keyword, bailout this
            # one
            if keyword and cmd != keyword:
                continue
            prefix = cmd
            if cmd == 'global':
                prefix = ''
            d = self.keywords[cmd]
            cprint('[%s]' % cmd, color='blue')
            self.__print_sub_level_tree(d, prefix)
        return


def print_full_help():
    if is_tty():
        cprint(BANNER)
    else:
        cprint(TXT_BANNER, color='blue')
    # Also print some quotes
    quote, from_film = get_quote()
    cprint('  >> %s  (%s)\n' % (quote, from_film), color='grey')
    
    parser.print_help()
    CLI.print_list()
    sys.exit(0)


if __name__ == '__main__':
    parser = optparse.OptionParser('', version="%prog " + VERSION, add_help_option=False)
    parser.add_option('--proxy', dest="proxy", help="""Proxy URI. Like http://user:password@proxy-server:3128""")
    parser.add_option('-l', '--list', action='store_true', dest="do_list", help=("List available commands"))
    parser.add_option('-D', action='store_true', dest="do_debug", help=("Enable the debug mode"))
    parser.add_option('-c', '--config', dest="jsonconfig", default=DEFAULT_CFG_FILE, help=("Path to your local.json file. Default: %s" % DEFAULT_CFG_FILE))
    parser.add_option('-v', action='store_true', dest="do_verbose", help=("Be more verbose"))
    parser.add_option('-h', '--help', action='store_true', dest="do_help", help=("Print help"))
    
    # First parsing, for purely internal parameters, but disable
    # errors, because we only want to see the -D -v things
    old_error = parser.error
    parser.error = lambda x: 1
    opts, args = parser.parse_args()
    # reenable the errors for later use
    parser.error = old_error
    
    # Is args are setting them, they must be force to the rest of the execution without looking at the configuration
    if opts.do_verbose:
        logger.setLevel('INFO', force=True)
    
    if opts.do_debug:
        logger.setLevel('DEBUG', force=True)
    
    cfg = None
    if not os.path.exists(opts.jsonconfig):
        logger.debug('Missing configuration file!')
    else:
        try:
            with open(opts.jsonconfig, 'r') as f:
                CONFIG = json.load(f)
            logger.debug("Loaded configuration file %s : %s" % (opts.jsonconfig, CONFIG))
        except Exception, exp:
            logger.error('Cannot load configuration file %s: %s' % (opts.jsonconfig, exp))
            sys.exit(2)
    
    CLI = CLICommander(CONFIG, opts)
    
    bash_completion_mode = ('EXEC_COMPLETION' in os.environ)
    
    # We will remove specific commands from the sys.argv list and keep
    # them for parsing them after
    # NOTE: in bash completion we do not want
    if not bash_completion_mode:
        command_args = CLI.hack_sys_argv()
    
    # Global command parsing, with the error enabled this time
    opts, args = parser.parse_args()
    
    logger.debug('CLI ARGS: %s' % args)
    
    if bash_completion_mode:
        CLI.print_completion(args)
        sys.exit(0)
    
    if opts.do_help:
        if len(command_args) == 0:
            logger.error("Cannot find any help for you")
            sys.exit(1)
        if len(command_args) == 1:
            sub_cmd = 'global'
        else:
            sub_cmd = command_args.pop(0)
        a = command_args.pop(0)
        if a not in CLI.keywords[sub_cmd]:
            logger.error("Cannot find any help for %s" % a)
            sys.exit(1)
        cprint('%s' % a, 'green')
        for arg in CLI.keywords[sub_cmd][a].args:
            n = arg.get('name', '')
            desc = arg.get('description', '')
            cprint('\t%s' % n.ljust(10), 'green', end='')
            cprint(': %s' % desc)
        
        sys.exit(0)
    
    # Maybe he/she just want to list our commands?
    if opts.do_list:
        CLI.print_list(' '.join(command_args))
        sys.exit(0)
    
    # if just call opsbro, we must show the available commands
    if len(command_args) == 0:
        print_full_help()
    
    # If it's just a one call shot, do it!
    CLI.one_loop(command_args)
